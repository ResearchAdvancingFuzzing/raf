
/*
  proto buf spec for Spitfire taint analysis tool output
*/

syntax = "proto3";

import "google/protobuf/timestamp.proto";

package spitfire;


service KnowledgeBase {

  // NOTE: Many of the message types contain uuids. When using RPC calls such
  // as GetProgram, GetInput, leave this field empty (don't specify uuid).
  // The knowledge base will compute or generate it and return a message of 
  // the same type containing the correct uuid and duplicating all other fields.

  // returns true iff exists in knowledge base
  // note: don't fill in uuid
  rpc ProgramExists(Program) returns (KnowledgeBaseResult) {}
  rpc InputExists(Input) returns (KnowledgeBaseResult) {}
  rpc CorpusExists(Corpus) returns (KnowledgeBaseResult) {}
  rpc ExperimentExists(Experiment) returns (KnowledgeBaseResult) {}
  rpc TaintEngineExists(TaintEngine) returns (KnowledgeBaseResult) {}
  rpc TaintAnalysisExists(TaintAnalysis) returns (KnowledgeBaseResult) {}

  // Add this item to kb
  // note UUID should not be filled in
  // returns the correct canonical protobuf representation
  rpc AddProgram(Program) returns (Program) {}
  rpc AddInput(Input) returns (Input) {}
  rpc AddCorpus(Corpus) returns (Corpus) {}
  rpc AddExperiment(Experiment) returns (Experiment) {}
  rpc AddTaintEngine(TaintEngine) returns (TaintEngine) {}
  rpc AddTaintAnalysis(TaintAnalysis) returns (TaintAnalysis) {}
  

  // Obtain canonical protobuf message for each from the knowledge base,
  // raise an exception if its not there.
  rpc GetProgram(Program) returns (Program) {}
  rpc GetInput(Input) returns (Input) {}
  rpc GetCorpus(Corpus) returns (Corpus) {}
  rpc GetExperiment(Experiment) returns (Experiment) {}
  rpc GetTaintEngine(TaintEngine) returns (TaintEngine) {}
  rpc GetTaintAnalysis(TaintAnalysis) returns (TaintAnalysis) {}

  // coverage API fns 
  // Andy and Heather?


  // Add a bunch of fuzzable byte sets to the knowledge base  
  // If any were already there, we dont add twice
  // return value indicates success / error
  rpc AddFuzzableByteSets (stream FuzzableByteSet) returns (KnowledgeBaseResult) {}

  // Add a bunch of tainted instructions to the knowledge base
  // If any were already there, we dont add twice
  rpc AddTaintedInstructions (stream TaintedInstruction) returns (KnowledgeBaseResult) {}
 
  // Add a bunch of taint mappings to the knowledge base.
  // note that a TaintMapping refers to a FuzzableByteSet and a 
  // TaintedInstruction, but by uuid only.  So you have to have called 
  // AddFuzzableByteSet and AddTaintedInstruction on the corresponding 
  // items beforehand.
  rpc AddTaintMappings (stream TaintMapping) returns (KnowledgeBaseResult) {}

  // Returns set of TaintedInstructions discovered thus far by 
  // all taint analyses that have run.
  rpc GetTaintedInstructions(Empty) returns (stream TaintedInstruction) {}

  // Returns set of Inputs that have been used to perform taint analysis 
  // thus far.
  rpc GetTaintInputs(Empty) returns (stream Input) {}

  // Returns set of Inputs that taint this instruction
  rpc GetTaintInputsForTantedInstruction(TaintedInstruction) returns (stream Input) {}

  // Returns set of FuzzableByteSets for this input
  rpc GetFuzzableBytesSetsForTaintInput(Input) returns (stream FuzzableByteSet) {}

  // Returns set of instructions seen to be tainted when we analyzed this input
  rpc GetTaintedInstructionsForTaintInput(Input) returns (stream TaintedInstruction) {}

  // Returns set of TaintMappings from this Input+FuzzableByteSet to this TaintedInstruction
  rpc GetTaintMappings(TaintMappingKey) returns (stream TaintMapping) {}    
    
}


message Empty {
}


// a program to be fuzzed
message Program {
  bytes uuid = 1;                   // compute this as md5sum of rest of this message
  string name = 2;                  // program name, like "awk" or "node" or "mount"
  string filepath = 3;              // path to file on spitfire shared file system
  string git_hash = 4;              // git hash string for version 
}


// an input to a program being fuzzed
message Input {
  bytes uuid = 1;                   // compute this as md5sum of input (file?) contents
  string filepath = 2;              // path to file on the spitfire shared file system 
}

// a set of inputs
message Corpus {
  bytes uuid = 1;                   // compute this as md5sum of all Input uuids
  string name = 2;                  // name for this corpus
  repeated Input input = 3;         // Inputs in this corpus
}


// A fuzzing experiment 
message Experiment {
  bytes uuid = 1;                       // Note: knowledge base assigned
  google.protobuf.Timestamp start = 2;  // start time of experiment (Note: knowledge base assigned)
  google.protobuf.Timestamp end = 3;    // end time of experiment (Note: knowledge base assigned)
  string description = 4;               // description of this experiment
  bytes program = 5;                    // uuid for the program fuzzed
  bytes seed_corpus = 6;                // uuid for seed corpus used
  uint64 prng_seed = 7;                 // seed of all randomness in this experiment
}


// generic response when no return value, to indicate success/fail
message KnowledgeBaseResult {
  bool success = 1;                 // true iff no error
  string message = 2;               // message, if necessary
}


message TaintEngine {
  bytes uuid = 1;                 //
  string name = 2;                // panda, e.g.
  string clone_string = 3;        // string to use to obtain correct version of taint engine,
                                  // this should uniquely identify version
                                  // for example, the following suffices 
                                  // for panda:
            		              // 'git clone -b spitfire_0 https://github.com/panda-re/panda.git'
}				    


message TaintAnalysis {
  bytes uuid = 1;
  // these three are uuids by the way
  bytes taint_engine = 2;      // the taint analysis tool 
  bytes program = 3;           // the target program 
  bytes input = 4;             // the input to that program
}
  

// A FuzzableByteSet is a set of input bytes that a taint analysis has 
// identified as influencing some program value at some point in execution.
// Assumes program input bytes (file, network, etc) are labeled with sequential
// integers (positional labels).
//
message FuzzableByteSet {
  bytes uuid = 1;                   // compute this as md5sum of label set 
  repeated uint32 label = 2;        // set of taint labels, i.e. input bytes 
}

 
//  An instruction that is tainted by a fuzzable byte set.  
//
message TaintedInstruction {
  bytes uuid = 1;                   // compute this as md5sum of rest of contents 
  uint64 pc = 2;                    // program counter within module 
  string module = 3;                // module this instruction is in 
  string type = 4;                  // type of instruction 
  bytes instr_bytes = 5;            // the bytes for this instruction
}
 

// Mapping from FuzzableByteSet to TaintedInstruction
//
message TaintMapping {
  bytes uuid = 1;
  bytes inp_uuid = 2;               // uuid of input 
  bytes fbs_uuid = 3;               // uuid of fuzzable byte set 
  bytes ti_uuid = 4;                // uuid of tainted instruction 
  uint64 value = 5;                 // actual internal program value that was tainted 
  uint32 value_length = 6;          // number of bytes in the tainted value 
  float trace_point = 7;            // where in program trace.  0=start, 1=end 
  uint32 min_compute_distance = 8;  // min compute distance for tainted byte in value 
  uint32 max_compute_distance = 9;  // max compute distance for tainted byte in value 
} 



// Used to identify a taint mapping in the knowledge base
//
message TaintMappingKey {
  Input input = 1;                  // The input for the taint analysis
  FuzzableByteSet fbs = 2;          // The set of bytes within that input
  TaintedInstruction ti = 3;        // The instruction tainted by those bytes
}
