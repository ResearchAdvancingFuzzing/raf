# RAF AFLFast
## Helpful Definitions
- fuzz = new interesting test cases arising 
- *p(i)* = the number of new inputs to be generated by an input *i* (aka *power*, *energy*)
- *f(i)* = the number of fuzz arising from input *i*
- *s(i)* = the number of times the input *i* has been chosen for fuzzing 
- *a(i)* = the performance score that AFL uses to compute fuzzing time for an input *i* (dependent on size and execution time)
## AFLFast Modifications
#### Power schedules (regulating time spent fuzzing an input)
- AFL's power schedule is constant in the number of times, *s(i)*, the input *i* has been chosen for fuzzing, while AFLFast is exponential in this value. AFLFast's method allows it to  exponentially approach the minimum energy required to discover a new interesting path, rather than starting with some constant that may be way too high or too low for this input. 
- AFL's power schedule only assigns high energy. Most fuzz exercises the same few paths and, as a result, too much energy gets assigned to high-frequency paths. AFLFast's power schedule assigns energy that is inversely proportional to the density of the stationary distribution (which they approximate for a state *i* by counting the number of fuzz *f(i)* that exercises the path *i*). 
- AFLFast includes 6 different versions of power schedules based on the above two points.
#### Search strategies (deciding which input is chosen next)
- In AFLFast, the decision of what input is chosen next purely based on the number the number of times an input has been fuzzed before (*s(i)*) and the amount of fuzz exercising the same path as the input (*f(i)*).
	- **Prioritizing small *s(i)***- this allows the fuzzer to establish early whether or not path *i* is a low-frequency path and whether it should invest more energy into fuzzing it 
	- **Prioritizing small *f(i)***- this allows the fuzzer to fuzz an input that exercises a low-frequency path, which might generate more inputs exercising low-frequency paths.
## AFL vs AFLFast Implementations
- AFL maintains a circular queue of inputs (starting with seed inputs and adding "interesting" inputs as they are discovered). 
- During each round of fuzzing/iteration of the fuzzing loop (`main`), AFL first favors some subset of inputs seen so far (chosen from its *top_rated[]* list of inputs) (`cull_queue`) and then chooses the next sequential input in the queue to fuzz (`fuzz_one`), wherein that input will more likely be fuzzed if it has been marked as favored. If that input does get fuzzed, AFL will calculate the desirability score for that input to adjust the length of havoc fuzzing  (`calculate_score`). 
- AFL's calculation of the desirability score directly affects the *power*, *p(i)* of that input *i*. This calculation involves the input's execution time and bitmap size, the cycle of the queue we are on, and the depth of that input. AFLFast modifies the computation of an input's performance score, adding 6 different variations of power schedules. 
- Each time a new, interesting input is found (i.e. we bump into a new path), AFL checks to see if the path is more "favorable" than any of the other existing ones (`update_bitmap_score`). AFL does this by maintaining a list of *top_rated[]* entries for every byte in the bitmap. In AFL, the input will win that slot if there if there is no previous contender or if the contender has a more favorable speed x size factor (small *a(i)*).  In AFLFast, the input will win that slot if there is no previous contender or if it has less fuzz than the previous contender (small *f(i)*). If it has equal fuzz to the previous contender, it will then only win if has a more favorable speed x size factor (small *a(i)*). This modification directly effects the *top_rated[]* and ultimately which inputs are marked as favorite (`cull_queue`). 
## AFLFast vs RAF AFLFast Implementations  
- RAF implements an AFLFast type fuzzing manager in `aflfast.py`. 
- Both RAF and AFL/AFLFast maintain a list of seed and interesting inputs. However, unlike AFL/AFLFast's sequential/circular queue, RAF maintains an unordered list; it does this by querying the knowledge base for all seed inputs and interesting inputs found so far and adding these to its list of inputs. 
- 
