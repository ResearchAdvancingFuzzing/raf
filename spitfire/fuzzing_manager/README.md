# RAF AFLFast
## Intro
RAF AFLFast is an impementation of AFLFast within the RAF modular framework. The implementation is not designed for speed; the goal is to be able to experiment and evaluate the changes that AFLFast has made to AFL in a structured and reproducible way. This document explains AFLFast's modifications to AFL for background and the differences between this RAF AFLFast and AFLFast. 
## Helpful Definitions
- fuzz = new interesting test cases arising 
- *p(i)* = the number of new inputs to be generated by an input *i* (aka *power*, *energy*)
- *f(i)* = the number of fuzz arising from input *i*
- *s(i)* = the number of times the input *i* has been chosen for fuzzing 
- *a(i)* = the performance score that AFL uses to compute fuzzing time for an input *i* (dependent on size and execution time)
## AFLFast Modifications
#### Power schedules (regulating time spent fuzzing an input)
- AFL's power schedule is constant in the number of times, *s(i)*, the input *i* has been chosen for fuzzing, while AFLFast is exponential in this value. AFLFast's method allows it to  exponentially approach the minimum energy required to discover a new interesting path, rather than starting with some constant that may be way too high or too low for this input. 
- AFL's power schedule only assigns high energy. Most fuzz exercises the same few paths and, as a result, too much energy gets assigned to high-frequency paths. AFLFast's power schedule assigns energy that is inversely proportional to the density of the stationary distribution (which they approximate for a state *i* by counting the number of fuzz *f(i)* that exercises the path *i*). 
- AFLFast includes 6 different versions of power schedules based on the above two points.
#### Search strategies (deciding which input is chosen next)
- In AFLFast, the decision of what input is chosen next is purely based on the number the number of times an input has been fuzzed before (*s(i)*) and the amount of fuzz exercising the same path as the input (*f(i)*).
	- **Prioritizing small *s(i)***- this allows the fuzzer to establish early whether or not path *i* is a low-frequency path and whether it should invest more energy into fuzzing it 
	- **Prioritizing small *f(i)***- this allows the fuzzer to fuzz an input that exercises a low-frequency path, which might generate more inputs exercising low-frequency paths.
## AFL vs AFLFast Implementations
- AFL maintains a circular queue of inputs (starting with seed inputs and adding "interesting" inputs as they are discovered). 
- During each round of fuzzing/iteration of the fuzzing loop (`main`), AFL first favors some subset of inputs seen so far (chosen from its *top_rated[]* list of inputs) (`cull_queue`) and then chooses the next sequential input in the queue to fuzz (`fuzz_one`); that input will more likely be fuzzed if it has been marked as favored. If that input does get fuzzed, AFL will then calculate the desirability score for that input to adjust the length of havoc fuzzing  (`calculate_score`). 
- AFL's calculation of the desirability score directly affects the *power*, *p(i)* of that input *i*. This calculation involves the input's execution time and bitmap size, the cycle of the queue we are on, and the depth of that input. AFLFast modifies this computation of an input's performance score, adding 6 different variations of power schedules to calculate this score. 
- Each time a new, interesting input is found (i.e. we bump into a new path), AFL checks to see if the path is more "favorable" than any of the other existing ones (`update_bitmap_score`). AFL does this by maintaining a list of *top_rated[]* entries for every byte in the bitmap. In AFL, the input will win that slot if there if there is no previous contender or if the contender has a more favorable speed x size factor (small *a(i)*).  In AFLFast, the input will win that slot if there is no previous contender or if it has less fuzz than the previous contender (small *f(i)*). If it has equal fuzz to the previous contender, it will then only win if has a more favorable speed x size factor (small *a(i)*). This modification directly effects the *top_rated[]* list and ultimately which inputs are marked as favorite (`cull_queue`). 
## AFLFast vs RAF AFLFast Implementations   
- RAF AFLFast implements an AFLFast type fuzzing manager in `aflfast.py`. This fuzzing manager (`aflfast.py`) implements all of the heuristics and analysis found in AFLFast to navigate its input search strategies and selection and determine its inputs' powers. 
#### Differences 
- AFL/AFLFast's fuzzing campaign utilizes the AFL fork server to fuzz new inputs; RAF AFLFast deploys a kubernetes job. 
- AFL/AFLFast uses global data to maintain its queue; RAF AFLFast uses the knowledge base server. 
- AFL/AFLFast calibrates test cases as soon as new, interesting inputs are found and added to the queue; RAF AFLFast calibrates cases found that it has not calibrated before as soon as it wakes up (it is a cron job). 
- A lot of the optimizations found in AFL/AFLFast (such as the trace_mini bitmap) are not implemented in RAF. It is not designed to be a fast fuzzer.
