# RAF AFLFast
## Helpful Definitions
- fuzz = new interesting test cases arising 
- *p(i)* = the number of new inputs to be generated by an input *i* (aka *power*, *energy*)
- *f(i)* = the number of fuzz arising from input *i*
- *s(i)* = the number of times the input *i* has been chosen for fuzzing 
- *a(i)* = the performance score that AFL uses to compute fuzzing time for an input *i* (dependent on size and execution time)
## AFLFast Modifications
#### Power schedules (regulating time spent fuzzing an input)
- AFL's power schedule is constant in the number of times, *s(i)*, the input *i* has been chosen for fuzzing, while AFLFast is exponential in this value. AFLFast's method allows it to  exponentially approach the minimum energy required to discover a new interesting path, rather than starting with some constant that may be way too high or too low for this input. 
- AFL's power schedule only assigns high energy. Most fuzz exercises the same few paths and, as a result, too much energy gets assigned to high-frequency paths. AFLFast's power schedule assigns energy that is inversely proportional to the density of the stationary distribution (which they approximate for a state *i* by counting the number of fuzz *f(i)* that exercises the path *i*). 
- AFLFast includes 6 different versions of power schedules based on the above two points.
#### Search strategies (deciding which input is chosen next)
- In AFLFast, the decision of what input is chosen next is purely based on the number the number of times an input has been fuzzed before (*s(i)*) and the amount of fuzz exercising the same path as the input (*f(i)*).
	- **Prioritizing small *s(i)***- this allows the fuzzer to establish early whether or not path *i* is a low-frequency path and whether it should invest more energy into fuzzing it 
	- **Prioritizing small *f(i)***- this allows the fuzzer to fuzz an input that exercises a low-frequency path, which might generate more inputs exercising low-frequency paths.
## AFL vs AFLFast Implementations
- AFL maintains a circular queue of inputs (starting with seed inputs and adding "interesting" inputs as they are discovered). 
- During each round of fuzzing/iteration of the fuzzing loop (`main`), AFL first favors some subset of inputs seen so far (chosen from its *top_rated[]* list of inputs) (`cull_queue`) and then chooses the next sequential input in the queue to fuzz (`fuzz_one`), wherein that input will more likely be fuzzed if it has been marked as favored. If that input does get fuzzed, AFL will calculate the desirability score for that input to adjust the length of havoc fuzzing  (`calculate_score`). 
- AFL's calculation of the desirability score directly affects the *power*, *p(i)* of that input *i*. This calculation involves the input's execution time and bitmap size, the cycle of the queue we are on, and the depth of that input. AFLFast modifies the computation of an input's performance score, adding 6 different variations of power schedules. 
- Each time a new, interesting input is found (i.e. we bump into a new path), AFL checks to see if the path is more "favorable" than any of the other existing ones (`update_bitmap_score`). AFL does this by maintaining a list of *top_rated[]* entries for every byte in the bitmap. In AFL, the input will win that slot if there if there is no previous contender or if the contender has a more favorable speed x size factor (small *a(i)*).  In AFLFast, the input will win that slot if there is no previous contender or if it has less fuzz than the previous contender (small *f(i)*). If it has equal fuzz to the previous contender, it will then only win if has a more favorable speed x size factor (small *a(i)*). This modification directly effects the *top_rated[]* and ultimately which inputs are marked as favorite (`cull_queue`). 
## AFLFast vs RAF AFLFast Implementations  
- RAF implements an AFLFast type fuzzing manager in `aflfast.py`. 
- Both RAF and AFL/AFLFast maintain a list of seed and interesting inputs. However, unlike AFL/AFLFast's sequential/circular queue, RAF maintains an unordered list; it does this by querying the knowledge base for all seed inputs and interesting inputs found so far and adding these to its list of inputs. 
- Both RAF andAFLFast "favor" inputs to fuzz next. AFLFast favors inputs by maintaining a list that pairs all potential paths in the program to a "top rated" input for that path, finding the minimal set of those inputs that cover all paths seen so far, and then "tagging" those inputs as favorable. (Note: a "top rated" input here is the input that has the fewest fuzz and, if none do, it is the input that has equal fuzz and a smaller size x speed factor (assuming it is not the only input seen so far; if it is, it is automatically the top rated input). RAF, on the other hand, simply sorts its list of inputs based on search strategies described in AFLFast (i.e. sorts the queue based on inputs that has the fewest fuzz / inputs that have been fuzzed the fewest times). Where inputs are chosen sequentially and potentially skipped over in AFLFast (if they are not favored), RAF always fuzzes the first input in its list.  
- When an input is finally chosen to fuzz, both RAF and AFLFast calculate a score (power) for that input test case and adjust the number of iterations spent havoc fuzzing based on that score. Both RAF and AFLFast use the exact same heuristics and power schedules to determine this time spent fuzzing.
-  When new, interesting inputs are found, both RAF and AFLFast calibrate the test case (calculating things like execution time and bitmap size). While AFLFast calibrates test cases as soon as new, interesting inputs are added, RAF, as soon as it wakes up, calibrates cases found that it has not calibrated before.
